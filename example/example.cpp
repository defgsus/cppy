/* generated by cppy on 2016-12-09 17:11:37.070037 */
#include <python3.4/Python.h>
#include <python3.4/structmember.h>
#ifndef CPPY_ERROR
#   include <iostream>
#   define CPPY_ERROR(arg__) { std::cerr << arg__ << std::endl; }
#endif
#ifndef CPPY_UNUSED
#   define CPPY_UNUSED(arg__) (void)arg__
#endif
/* compatibility checks */
#include <type_traits>
static_assert(std::is_same<reprfunc,
    PyObject*(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<hashfunc,
    Py_hash_t(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<binaryfunc,
    PyObject*(*)(PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<printfunc,
    int(*)(PyObject*, FILE*, int)>::value, "cppy/python api mismatch");
static_assert(std::is_same<freefunc,
    void(*)(void*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<getiterfunc,
    PyObject*(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<ssizessizeobjargproc,
    int(*)(PyObject*, Py_ssize_t, Py_ssize_t, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<richcmpfunc,
    PyObject*(*)(PyObject*, PyObject*, int)>::value, "cppy/python api mismatch");
static_assert(std::is_same<descrsetfunc,
    int(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<ssizeobjargproc,
    int(*)(PyObject*, Py_ssize_t, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<objobjargproc,
    int(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<ternaryfunc,
    PyObject*(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<setattrfunc,
    int(*)(PyObject*, char*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<ssizessizeargfunc,
    PyObject*(*)(PyObject*, Py_ssize_t, Py_ssize_t)>::value, "cppy/python api mismatch");
static_assert(std::is_same<ssizeargfunc,
    PyObject*(*)(PyObject*, Py_ssize_t)>::value, "cppy/python api mismatch");
static_assert(std::is_same<lenfunc,
    Py_ssize_t(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<getter,
    PyObject*(*)(PyObject*, void*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<destructor,
    void(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<allocfunc,
    PyObject*(*)(struct _typeobject*, Py_ssize_t)>::value, "cppy/python api mismatch");
static_assert(std::is_same<setattrofunc,
    int(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<inquiry,
    int(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<newfunc,
    PyObject*(*)(struct _typeobject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<iternextfunc,
    PyObject*(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<setter,
    int(*)(PyObject*, PyObject*, void*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<initproc,
    int(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<getattrfunc,
    PyObject*(*)(PyObject*, char*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<unaryfunc,
    PyObject*(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<descrgetfunc,
    PyObject*(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<getattrofunc,
    PyObject*(*)(PyObject*, PyObject*)>::value, "cppy/python api mismatch");


/* forwards */
namespace {
extern "C" {
    /* Abel forward decl */
    struct Abel_struct;
    static Abel_struct* cppy_new_Abel_struct(struct _typeobject *, PyObject *, PyObject *);
    static void cppy_dealloc_Abel_struct(PyObject* self);
    static Abel_struct* cppy_copy_Abel_struct(Abel_struct* self);
    static bool cppy_is_instance_Abel_struct(PyObject* arg);
    /* Kain forward decl */
    struct Kain_struct;
    static Kain_struct* cppy_new_Kain_struct(struct _typeobject *, PyObject *, PyObject *);
    static void cppy_dealloc_Kain_struct(PyObject* self);
    static Kain_struct* cppy_copy_Kain_struct(Kain_struct* self);
    static bool cppy_is_instance_Kain_struct(PyObject* arg);

} // extern "C"
} // namespace

/* declarations from configuration */

/* user declarations */
// This part will be included in the generated .cpp file
// We pull in some helper functions here because CPython is really low-level..
#include "py_utils.h"

/* python c-api tango */

namespace {

/* #################### global functions ##################### */

extern "C" {
    /* example.py:14 */
    /* ArgSpec(args=[], varargs=None, keywords=None, defaults=None) */
    static const char* cppy_func_a_doc = "func_a() -> float\nReturns 444.";
    static PyObject* cppy_func_a(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        return toPython(444.);
    }
    /* example.py:23 */
    /* ArgSpec(args=['a', 'b'], varargs=None, keywords=None, defaults=None) */
    static const char* cppy_func_add_doc = "func_add(float, float) -> float\nAdds two numbers";
    static PyObject* cppy_func_add(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        double a, b;
        if (!PyArg_ParseTuple(arg1, "dd", &a, &b))
            return NULL;
        return toPython(a+b);
    }

    static PyMethodDef cppy_module_methods_example[] =
    {
        { "func_a", reinterpret_cast<PyCFunction>(cppy_func_a), METH_NOARGS, cppy_func_a_doc },
        { "func_add", reinterpret_cast<PyCFunction>(cppy_func_add), METH_VARARGS, cppy_func_add_doc },
        { NULL, NULL, 0, NULL }
    };
} // extern "C"

/* #################### class Abel ##################### */

extern "C" {
    /* class 'Abel' */
    struct Abel_struct
    {
        PyObject_HEAD
        // These are c++ members of the class
        std::string* data;
        void cppy_new()
        {
            // When object is created we have to initialize all members ourselves
            CPPY_PRINT("NEW Abel");
            data = new std::string();
        }
        void cppy_free()
        {
            CPPY_PRINT("FREE Abel");
            delete data;
        }
        void cppy_copy(Abel_struct* copy)
        {
            CPPY_UNUSED(copy);
            // An internal copy function you can use later
            // Should copy all members to instance 'copy'
            *copy->data = *data;
        }
    };
    static const char* Abel_struct_doc_string = "An example to create a embedded class object";


/* ---------- Abel methods ----------- */

    /* example.py:69 */
    /* ArgSpec(args=['self', 'other'], varargs=None, keywords=None, defaults=None) */
    static PyObject* cppy_classmethod_Abel___eq__(PyObject* arg0, PyObject* arg1, int arg2)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); CPPY_UNUSED(arg2); 
        Abel_struct* self = reinterpret_cast<Abel_struct*>(arg0);
        if (!cppy_is_instance_Abel_struct(arg1))
        {
            setPythonError(PyExc_TypeError, SStream() << "Expected Abel, got " << typeName(arg1));
            return NULL;
        }
        return toPython(*self->data == *(reinterpret_cast<Abel_struct*>(arg1)->data));
    }
    /* example.py:56 */
    /* ArgSpec(args=['self', 'arg'], varargs=None, keywords=None, defaults=None) */
    static int cppy_classmethod_Abel___init__(PyObject* arg0, PyObject* arg1, PyObject* arg2)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); CPPY_UNUSED(arg2); 
        Abel_struct* self = reinterpret_cast<Abel_struct*>(arg0);
        // __init__ functions are always called as METH_VARARGS function
        // so 'arg1' is always a tuple and 'arg2' is a dict with keywords
        arg1 = removeArgumentTuple(arg1);
        if (fromPython(arg1, self->data))
            return 0;
        return 0;
    }
    /* example.py:82 */
    /* ArgSpec(args=['self'], varargs=None, keywords=None, defaults=None) */
    static PyObject* cppy_classmethod_Abel___repr__(PyObject* arg0)
    {
        CPPY_UNUSED(arg0); 
        Abel_struct* self = reinterpret_cast<Abel_struct*>(arg0);
        return toPython(SStream() << "Abel@" << (void*)self);
    }
    /* example.py:89 */
    /* ArgSpec(args=['self'], varargs=None, keywords=None, defaults=None) */
    static PyObject* cppy_classmethod_Abel___str__(PyObject* arg0)
    {
        CPPY_UNUSED(arg0); 
        Abel_struct* self = reinterpret_cast<Abel_struct*>(arg0);
        return toPython(SStream() << "Abel(\"" << *self->data << "\")");
    }
    /* example.py:96 */
    /* ArgSpec(args=['self'], varargs=None, keywords=None, defaults=None) */
    static const char* cppy_classmethod_Abel_copy_doc = "copy() -> Abel\nReturns a copy of the object";
    static PyObject* cppy_classmethod_Abel_copy(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Abel_struct* self = reinterpret_cast<Abel_struct*>(arg0);
        return (PyObject*)cppy_copy_Abel_struct(self);
    }
    /* example.py:126 */
    /* ArgSpec(args=['self'], varargs=None, keywords=None, defaults=None) */
    static const char* cppy_classmethod_Abel_get_doc = "get() -> string\nReturns the contents as string";
    static PyObject* cppy_classmethod_Abel_get(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Abel_struct* self = reinterpret_cast<Abel_struct*>(arg0);
        return toPython(self->data);
    }
    /* example.py:105 */
    /* ArgSpec(args=['self', 'arg'], varargs=None, keywords=None, defaults=None) */
    static const char* cppy_classmethod_Abel_set_doc = "set(string) -> self\nSets the contents of the object";
    static PyObject* cppy_classmethod_Abel_set(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Abel_struct* self = reinterpret_cast<Abel_struct*>(arg0);
        if (!expectFromPython(arg1, self->data))
            return NULL;
        Py_RETURN_SELF;
    }


/* ---------- Abel properties ----------- */

    static const char* Abel_wisdom_doc = "A property";
    static PyObject* Abel_wisdom_getter(PyObject* arg0, void* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Abel_struct* self = reinterpret_cast<Abel_struct*>(arg0);
        // A property is like a normal class function in the c-api
        return toPython(7.);
    }


/* ---------- Abel structs ----------- */


    static PyMethodDef Abel_method_struct[] =
    {
        { "copy", reinterpret_cast<PyCFunction>(cppy_classmethod_Abel_copy), METH_NOARGS, cppy_classmethod_Abel_copy_doc },
        { "get", reinterpret_cast<PyCFunction>(cppy_classmethod_Abel_get), METH_NOARGS, cppy_classmethod_Abel_get_doc },
        { "set", reinterpret_cast<PyCFunction>(cppy_classmethod_Abel_set), METH_O, cppy_classmethod_Abel_set_doc },
        { NULL, NULL, 0, NULL }
    };

    static PyGetSetDef Abel_getset_struct[] =
    {
        { (char*)"wisdom", (getter)Abel_wisdom_getter, (setter)NULL, (char*)Abel_wisdom_doc, (void*)NULL },
        { NULL, NULL, NULL, NULL, NULL }
    };

    static PyTypeObject Abel_type_static_mem =
    {
        PyVarObject_HEAD_INIT(NULL, 0)
        /* tp_name */           static_cast<const char*>        ("Abel.Abel"),
        /* tp_basicsize */      static_cast<Py_ssize_t>         (sizeof(Abel_struct)),
        /* tp_itemsize */       static_cast<Py_ssize_t>         (NULL),
        /* tp_dealloc */        static_cast<destructor>         (cppy_dealloc_Abel_struct),
        /* tp_print */          static_cast<printfunc>          (NULL),
        /* tp_getattr */        static_cast<getattrfunc>        (NULL),
        /* tp_setattr */        static_cast<setattrfunc>        (NULL),
        /* tp_reserved */       static_cast<void*>              (NULL),
        /* tp_repr */           static_cast<reprfunc>           (cppy_classmethod_Abel___repr__),
        /* tp_as_number */      static_cast<PyNumberMethods*>   (NULL),
        /* tp_as_sequence */    static_cast<PySequenceMethods*> (NULL),
        /* tp_as_mapping */     static_cast<PyMappingMethods*>  (NULL),
        /* tp_hash */           static_cast<hashfunc>           (NULL),
        /* tp_call */           static_cast<ternaryfunc>        (NULL),
        /* tp_str */            static_cast<reprfunc>           (cppy_classmethod_Abel___str__),
        /* tp_getattro */       static_cast<getattrofunc>       (PyObject_GenericGetAttr),
        /* tp_setattro */       static_cast<setattrofunc>       (PyObject_GenericSetAttr),
        /* tp_as_buffer */      static_cast<PyBufferProcs*>     (NULL),
        /* tp_flags */          static_cast<unsigned long>      (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE),
        /* tp_doc */            static_cast<const char*>        (Abel_struct_doc_string),
        /* tp_traverse */       static_cast<traverseproc>       (NULL),
        /* tp_clear */          static_cast<inquiry>            (NULL),
        /* tp_richcompare */    static_cast<richcmpfunc>        (cppy_classmethod_Abel___eq__),
        /* tp_weaklistoffset */ static_cast<Py_ssize_t>         (NULL),
        /* tp_iter */           static_cast<getiterfunc>        (NULL),
        /* tp_iternext */       static_cast<iternextfunc>       (NULL),
        /* tp_methods */        static_cast<struct PyMethodDef*>(Abel_method_struct),
        /* tp_members */        static_cast<struct PyMemberDef*>(NULL),
        /* tp_getset */         static_cast<struct PyGetSetDef*>(Abel_getset_struct),
        /* tp_base */           static_cast<struct _typeobject*>(NULL),
        /* tp_dict */           static_cast<PyObject*>          (NULL),
        /* tp_descr_get */      static_cast<descrgetfunc>       (NULL),
        /* tp_descr_set */      static_cast<descrsetfunc>       (NULL),
        /* tp_dictoffset */     static_cast<Py_ssize_t>         (NULL),
        /* tp_init */           static_cast<initproc>           (cppy_classmethod_Abel___init__),
        /* tp_alloc */          static_cast<allocfunc>          (NULL),
        /* tp_new */            reinterpret_cast<newfunc>       (cppy_new_Abel_struct),
        /* tp_free */           static_cast<freefunc>           (NULL),
        /* tp_is_gc */          static_cast<inquiry>            (NULL),
        /* tp_bases */          static_cast<PyObject*>          (NULL),
        /* tp_mro */            static_cast<PyObject*>          (NULL),
        /* tp_cache */          static_cast<PyObject*>          (NULL),
        /* tp_subclasses */     static_cast<PyObject*>          (NULL),
        /* tp_weaklist */       static_cast<PyObject*>          (NULL),
        /* tp_del */            static_cast<destructor>         (NULL),
        /* tp_version_tag */    static_cast<unsigned int>       (NULL),
        /* tp_finalize */       static_cast<destructor>         (NULL)
    }; /* Abel_type_static_mem */


/* ---------- Abel ctor/dtor ----------- */


    /* ###### class Abel ###### */
    /** Creates new instance of Abel class.
        @note Original function signature requires to return PyObject*,
        but here we return the actual Abel struct for convenience. */
    Abel_struct* cppy_new_Abel_struct(struct _typeobject *, PyObject* , PyObject* )
    {
        auto o = PyObject_New(Abel_struct, &Abel_type_static_mem);
        // Needs to be implemented by user in class Abel's cpp annotation
        o->cppy_new();
        return o;
    }
    /** Deletes a Abel instance */
    void cppy_dealloc_Abel_struct(PyObject* self)
    {
        // Needs to be implemented by user in class Abel's cpp annotation
        reinterpret_cast<Abel_struct*>(self)->cppy_free();
        self->ob_type->tp_free(self);
    }
    /** Makes a copy of the Abel instance @p self,
        using user-supplied Abel_struct::cppy_copy() */
    Abel_struct* cppy_copy_Abel_struct(Abel_struct* self)
    {
        Abel_struct* copy = cppy_new_Abel_struct(&Abel_type_static_mem,NULL,NULL);
        // Needs to be implemented by user in class Abel's cpp annotation
        self->cppy_copy(copy);
        return copy;
    }
    /** Wrapper for type checking after declaration of Abel_type_static_mem */
    bool cppy_is_instance_Abel_struct(PyObject* arg)
    {
        return PyObject_TypeCheck(arg, &Abel_type_static_mem);
    }

} // extern "C"

bool initialize_class_Abel(void* vmodule)
{
    PyObject* module = reinterpret_cast<PyObject*>(vmodule);
    if (0 != PyType_Ready(&Abel_type_static_mem))
    {
        CPPY_ERROR("Failed to readify class Abel for Python 3.4 module");
        return false;
    }
    PyObject* object = reinterpret_cast<PyObject*>(&Abel_type_static_mem);
    Py_INCREF(object);
    if (0 != PyModule_AddObject(module, "Abel", object))
    {
        Py_DECREF(object);
        CPPY_ERROR("Failed to add class Abel to Python 3.4 module");
        return false;
    }
    return true;
}

/* #################### class Kain ##################### */

extern "C" {
    /* class 'Kain' */
    struct Kain_struct
    {
        PyObject_HEAD
        // These are c++ members of the class
        std::string* data;
        void cppy_new()
        {
            // When object is created we have to initialize all members ourselves
            CPPY_PRINT("NEW Kain");
            data = new std::string();
        }
        void cppy_free()
        {
            CPPY_PRINT("FREE Kain");
            delete data;
        }
        void cppy_copy(Kain_struct* copy)
        {
            CPPY_UNUSED(copy);
            // An internal copy function you can use later
            // Should copy all members to instance 'copy'
            *copy->data = *data;
        }
    };
    static const char* Kain_struct_doc_string = "";


/* ---------- Kain methods ----------- */

    /* example.py:69 */
    /* ArgSpec(args=['self', 'other'], varargs=None, keywords=None, defaults=None) */
    static PyObject* cppy_classmethod_Kain___eq__(PyObject* arg0, PyObject* arg1, int arg2)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); CPPY_UNUSED(arg2); 
        Kain_struct* self = reinterpret_cast<Kain_struct*>(arg0);
        if (!cppy_is_instance_Kain_struct(arg1))
        {
            setPythonError(PyExc_TypeError, SStream() << "Expected Kain, got " << typeName(arg1));
            return NULL;
        }
        return toPython(*self->data == *(reinterpret_cast<Kain_struct*>(arg1)->data));
    }
    /* example.py:56 */
    /* ArgSpec(args=['self', 'arg'], varargs=None, keywords=None, defaults=None) */
    static int cppy_classmethod_Kain___init__(PyObject* arg0, PyObject* arg1, PyObject* arg2)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); CPPY_UNUSED(arg2); 
        Kain_struct* self = reinterpret_cast<Kain_struct*>(arg0);
        // __init__ functions are always called as METH_VARARGS function
        // so 'arg1' is always a tuple and 'arg2' is a dict with keywords
        arg1 = removeArgumentTuple(arg1);
        if (fromPython(arg1, self->data))
            return 0;
        return 0;
    }
    /* example.py:82 */
    /* ArgSpec(args=['self'], varargs=None, keywords=None, defaults=None) */
    static PyObject* cppy_classmethod_Kain___repr__(PyObject* arg0)
    {
        CPPY_UNUSED(arg0); 
        Kain_struct* self = reinterpret_cast<Kain_struct*>(arg0);
        return toPython(SStream() << "Kain@" << (void*)self);
    }
    /* example.py:89 */
    /* ArgSpec(args=['self'], varargs=None, keywords=None, defaults=None) */
    static PyObject* cppy_classmethod_Kain___str__(PyObject* arg0)
    {
        CPPY_UNUSED(arg0); 
        Kain_struct* self = reinterpret_cast<Kain_struct*>(arg0);
        return toPython(SStream() << "Kain(\"" << *self->data << "\")");
    }
    /* example.py:96 */
    /* ArgSpec(args=['self'], varargs=None, keywords=None, defaults=None) */
    static const char* cppy_classmethod_Kain_copy_doc = "copy() -> Abel\nReturns a copy of the object";
    static PyObject* cppy_classmethod_Kain_copy(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Kain_struct* self = reinterpret_cast<Kain_struct*>(arg0);
        return (PyObject*)cppy_copy_Kain_struct(self);
    }
    /* example.py:126 */
    /* ArgSpec(args=['self'], varargs=None, keywords=None, defaults=None) */
    static const char* cppy_classmethod_Kain_get_doc = "get() -> string\nReturns the contents as string";
    static PyObject* cppy_classmethod_Kain_get(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Kain_struct* self = reinterpret_cast<Kain_struct*>(arg0);
        return toPython(self->data);
    }
    /* example.py:105 */
    /* ArgSpec(args=['self', 'arg'], varargs=None, keywords=None, defaults=None) */
    static const char* cppy_classmethod_Kain_set_doc = "set(string) -> self\nSets the contents of the object";
    static PyObject* cppy_classmethod_Kain_set(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Kain_struct* self = reinterpret_cast<Kain_struct*>(arg0);
        if (!expectFromPython(arg1, self->data))
            return NULL;
        Py_RETURN_SELF;
    }
    /* example.py:140 */
    /* ArgSpec(args=['self'], varargs=None, keywords=None, defaults=None) */
    static const char* cppy_classmethod_Kain_slay_doc = "Slays Abel";
    static PyObject* cppy_classmethod_Kain_slay(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Kain_struct* self = reinterpret_cast<Kain_struct*>(arg0);
        CPPY_PRINT("Kain(" << *self->data << ") slew Abel");
        Py_RETURN_NONE;
    }


/* ---------- Kain properties ----------- */

    static const char* Kain_wisdom_doc = "A property";
    static PyObject* Kain_wisdom_getter(PyObject* arg0, void* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Kain_struct* self = reinterpret_cast<Kain_struct*>(arg0);
        // A property is like a normal class function in the c-api
        return toPython(7.);
    }


/* ---------- Kain structs ----------- */


    static PyMethodDef Kain_method_struct[] =
    {
        { "copy", reinterpret_cast<PyCFunction>(cppy_classmethod_Kain_copy), METH_NOARGS, cppy_classmethod_Kain_copy_doc },
        { "get", reinterpret_cast<PyCFunction>(cppy_classmethod_Kain_get), METH_NOARGS, cppy_classmethod_Kain_get_doc },
        { "set", reinterpret_cast<PyCFunction>(cppy_classmethod_Kain_set), METH_O, cppy_classmethod_Kain_set_doc },
        { "slay", reinterpret_cast<PyCFunction>(cppy_classmethod_Kain_slay), METH_NOARGS, cppy_classmethod_Kain_slay_doc },
        { NULL, NULL, 0, NULL }
    };

    static PyGetSetDef Kain_getset_struct[] =
    {
        { (char*)"wisdom", (getter)Kain_wisdom_getter, (setter)NULL, (char*)Kain_wisdom_doc, (void*)NULL },
        { NULL, NULL, NULL, NULL, NULL }
    };

    static PyTypeObject Kain_type_static_mem =
    {
        PyVarObject_HEAD_INIT(NULL, 0)
        /* tp_name */           static_cast<const char*>        ("Kain.Kain"),
        /* tp_basicsize */      static_cast<Py_ssize_t>         (sizeof(Kain_struct)),
        /* tp_itemsize */       static_cast<Py_ssize_t>         (NULL),
        /* tp_dealloc */        static_cast<destructor>         (cppy_dealloc_Kain_struct),
        /* tp_print */          static_cast<printfunc>          (NULL),
        /* tp_getattr */        static_cast<getattrfunc>        (NULL),
        /* tp_setattr */        static_cast<setattrfunc>        (NULL),
        /* tp_reserved */       static_cast<void*>              (NULL),
        /* tp_repr */           static_cast<reprfunc>           (cppy_classmethod_Kain___repr__),
        /* tp_as_number */      static_cast<PyNumberMethods*>   (NULL),
        /* tp_as_sequence */    static_cast<PySequenceMethods*> (NULL),
        /* tp_as_mapping */     static_cast<PyMappingMethods*>  (NULL),
        /* tp_hash */           static_cast<hashfunc>           (NULL),
        /* tp_call */           static_cast<ternaryfunc>        (NULL),
        /* tp_str */            static_cast<reprfunc>           (cppy_classmethod_Kain___str__),
        /* tp_getattro */       static_cast<getattrofunc>       (PyObject_GenericGetAttr),
        /* tp_setattro */       static_cast<setattrofunc>       (PyObject_GenericSetAttr),
        /* tp_as_buffer */      static_cast<PyBufferProcs*>     (NULL),
        /* tp_flags */          static_cast<unsigned long>      (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE),
        /* tp_doc */            static_cast<const char*>        (Kain_struct_doc_string),
        /* tp_traverse */       static_cast<traverseproc>       (NULL),
        /* tp_clear */          static_cast<inquiry>            (NULL),
        /* tp_richcompare */    static_cast<richcmpfunc>        (cppy_classmethod_Kain___eq__),
        /* tp_weaklistoffset */ static_cast<Py_ssize_t>         (NULL),
        /* tp_iter */           static_cast<getiterfunc>        (NULL),
        /* tp_iternext */       static_cast<iternextfunc>       (NULL),
        /* tp_methods */        static_cast<struct PyMethodDef*>(Kain_method_struct),
        /* tp_members */        static_cast<struct PyMemberDef*>(NULL),
        /* tp_getset */         static_cast<struct PyGetSetDef*>(Kain_getset_struct),
        /* tp_base */           static_cast<struct _typeobject*>(NULL),
        /* tp_dict */           static_cast<PyObject*>          (NULL),
        /* tp_descr_get */      static_cast<descrgetfunc>       (NULL),
        /* tp_descr_set */      static_cast<descrsetfunc>       (NULL),
        /* tp_dictoffset */     static_cast<Py_ssize_t>         (NULL),
        /* tp_init */           static_cast<initproc>           (cppy_classmethod_Kain___init__),
        /* tp_alloc */          static_cast<allocfunc>          (NULL),
        /* tp_new */            reinterpret_cast<newfunc>       (cppy_new_Kain_struct),
        /* tp_free */           static_cast<freefunc>           (NULL),
        /* tp_is_gc */          static_cast<inquiry>            (NULL),
        /* tp_bases */          static_cast<PyObject*>          (NULL),
        /* tp_mro */            static_cast<PyObject*>          (NULL),
        /* tp_cache */          static_cast<PyObject*>          (NULL),
        /* tp_subclasses */     static_cast<PyObject*>          (NULL),
        /* tp_weaklist */       static_cast<PyObject*>          (NULL),
        /* tp_del */            static_cast<destructor>         (NULL),
        /* tp_version_tag */    static_cast<unsigned int>       (NULL),
        /* tp_finalize */       static_cast<destructor>         (NULL)
    }; /* Kain_type_static_mem */


/* ---------- Kain ctor/dtor ----------- */


    /* ###### class Kain ###### */
    /** Creates new instance of Kain class.
        @note Original function signature requires to return PyObject*,
        but here we return the actual Kain struct for convenience. */
    Kain_struct* cppy_new_Kain_struct(struct _typeobject *, PyObject* , PyObject* )
    {
        auto o = PyObject_New(Kain_struct, &Kain_type_static_mem);
        // Needs to be implemented by user in class Kain's cpp annotation
        o->cppy_new();
        return o;
    }
    /** Deletes a Kain instance */
    void cppy_dealloc_Kain_struct(PyObject* self)
    {
        // Needs to be implemented by user in class Kain's cpp annotation
        reinterpret_cast<Kain_struct*>(self)->cppy_free();
        self->ob_type->tp_free(self);
    }
    /** Makes a copy of the Kain instance @p self,
        using user-supplied Kain_struct::cppy_copy() */
    Kain_struct* cppy_copy_Kain_struct(Kain_struct* self)
    {
        Kain_struct* copy = cppy_new_Kain_struct(&Kain_type_static_mem,NULL,NULL);
        // Needs to be implemented by user in class Kain's cpp annotation
        self->cppy_copy(copy);
        return copy;
    }
    /** Wrapper for type checking after declaration of Kain_type_static_mem */
    bool cppy_is_instance_Kain_struct(PyObject* arg)
    {
        return PyObject_TypeCheck(arg, &Kain_type_static_mem);
    }

} // extern "C"

bool initialize_class_Kain(void* vmodule)
{
    PyObject* module = reinterpret_cast<PyObject*>(vmodule);
    if (0 != PyType_Ready(&Kain_type_static_mem))
    {
        CPPY_ERROR("Failed to readify class Kain for Python 3.4 module");
        return false;
    }
    PyObject* object = reinterpret_cast<PyObject*>(&Kain_type_static_mem);
    Py_INCREF(object);
    if (0 != PyModule_AddObject(module, "Kain", object))
    {
        Py_DECREF(object);
        CPPY_ERROR("Failed to add class Kain to Python 3.4 module");
        return false;
    }
    return true;
}

extern "C" {
    /* module definition for 'example' */
    static const char* cppy_module_example_doc = "Example module to demonstrate cppy\n\n";
    static PyModuleDef cppy_module_example =
    {
        PyModuleDef_HEAD_INIT,
        /* m_name */     static_cast<const char*> ("example"),
        /* m_doc */      static_cast<const char*> (cppy_module_example_doc),
        /* m_size */     static_cast<Py_ssize_t>  (-1),
        /* m_methods */  static_cast<PyMethodDef*>(static_cast<PyMethodDef*>(cppy_module_methods_example)),
        /* m_reload */   static_cast<inquiry>     (NULL),
        /* m_traverse */ static_cast<traverseproc>(NULL),
        /* m_clear */    static_cast<inquiry>     (NULL),
        /* m_free */     static_cast<freefunc>    (NULL)
    }; /* cppy_module_example */
} // extern "C"

} // namespace

namespace {
    PyMODINIT_FUNC create_module_func()
    {
        auto module = PyModule_Create(&cppy_module_example);
        if (!module)
            return nullptr;
        // add the classes
        initialize_class_Abel(module);
        initialize_class_Kain(module);
        return module;
    }
} // namespace
bool initialize_module_example()
{
    PyImport_AppendInittab("example", create_module_func);
    return true;
}


/* footer from configuration */
